name: Remote Tunnel Access
on: 
  workflow_dispatch: # Only run manually

jobs:
  dev_tunnel:
    runs-on: windows-latest
    # Set a reasonable timeout for your debugging/development session
    timeout-minutes: 360
    
    steps:
      # 1. Download and Extract the VS Code CLI
      - name: Download VS Code CLI
        run: |
          Invoke-WebRequest -Uri "https://code.visualstudio.com/sha/download?build=stable&os=cli-win32-x64" -OutFile vscode-cli.zip
          Expand-Archive vscode-cli.zip -DestinationPath vscli -Force
        shell: pwsh

      # 2. Start the VS Code Remote Tunnel
      - name: Start VS Code Tunnel
        run: |
          # Create a log file for the tunnel output
          $logFile = "tunnel.log"
          
          # Start tunnel in background and redirect output to log file
          $process = Start-Process -FilePath ".\vscli\code.exe" `
            -ArgumentList "tunnel", "--accept-server-license-terms" `
            -NoNewWindow `
            -PassThru `
            -RedirectStandardOutput $logFile `
            -RedirectStandardError "tunnel-error.log"
          
          Write-Host "Tunnel process started with PID: $($process.Id)"
          Write-Host "Waiting for tunnel to initialize..."
          
          # Wait and monitor the log file for the URL
          $urlFound = $false
          $maxWaitTime = 120 # Wait up to 2 minutes for URL
          $elapsed = 0
          
          while (-not $urlFound -and $elapsed -lt $maxWaitTime) {
            Start-Sleep -Seconds 5
            $elapsed += 5
            
            if (Test-Path $logFile) {
              $logContent = Get-Content $logFile -Raw
              Write-Host "`n--- Tunnel Output ---"
              Write-Host $logContent
              Write-Host "--- End Output ---`n"
              
              # Check if URL is in the output
              if ($logContent -match "vscode\.dev/tunnel/") {
                $urlFound = $true
                Write-Host "`n=========================================="
                Write-Host "TUNNEL IS READY!"
                Write-Host "=========================================="
              }
            }
            
            # Check if process is still running
            if ($process.HasExited) {
              Write-Host "ERROR: Tunnel process exited unexpectedly!"
              if (Test-Path "tunnel-error.log") {
                Write-Host "`n--- Error Log ---"
                Get-Content "tunnel-error.log"
              }
              exit 1
            }
          }
          
          if (-not $urlFound) {
            Write-Host "WARNING: URL not detected yet, but tunnel is running..."
          }
          
          # Keep the job alive
          Write-Host "`nKeeping tunnel alive. Press Ctrl+C in Actions to stop."
          Write-Host "Monitoring tunnel process (PID: $($process.Id))...`n"
          
          while (-not $process.HasExited) {
            Start-Sleep -Seconds 30
            
            # Show periodic updates
            if (Test-Path $logFile) {
              $newContent = Get-Content $logFile -Raw
              if ($newContent.Length -gt $logContent.Length) {
                $logContent = $newContent
                Write-Host "[$(Get-Date -Format 'HH:mm:ss')] New tunnel output:"
                Write-Host $logContent
              } else {
                Write-Host "[$(Get-Date -Format 'HH:mm:ss')] Tunnel is running..."
              }
            }
          }
          
          Write-Host "Tunnel process has ended."
          exit 1
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.VSCODE_PAT }}

      # Alternative: Simple keep-alive (if the above doesn't work)
      # - name: Keep Job Alive (Alternative)
      #   run: |
      #     while ($true) {
      #       Write-Host "Tunnel is running... ($(Get-Date))"
      #       Start-Sleep -Seconds 60
      #     }
      #   shell: pwsh
